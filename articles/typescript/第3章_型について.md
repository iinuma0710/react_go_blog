# 第3章 型について
TypeScript において，型 (type) とは「値とそれを使ってできる事柄の集まり」を表します．

- ```boolean``` 型は，ブール値と，それらに行える論理積や論理和，論理否定などの演算の集まり
- ```number``` 型は，全ての数値と，それに対して行える四則演算や論理演算，及び ```toFixed```，```toPrecision```，```toString``` などのメソッドの集まり
- ```string``` 型は，全ての文字列と，それに対して適応できる演算，及び ```concat``` や ```toUpperCase``` などのメソッドの集まり

ある型 ```T``` であることがわかれば，その ```T``` を使って「何ができるか」まで知ることができます．
ここでは，TypeScript で利用可能な型を紹介し，それらを使って何ができるかについて見ていきます．

## 3.1 型についての議論
例えば，何らかの値を取って，それを2乗した値を返す関数を考えます．

```ts
function squareOf(n) {
    return n * n
}

squareOf(2)     // 4 と評価されます
squareOf('z')   // NaN と評価されます
```

この関数が数値についてのみ機能することは明らかです．
そこで，パラメータの型を明示的に**アノテートする** (annotate)ことで，数値以外をこの関数に渡すと不正な結果になるようにします．

```ts
function squareOf(n: number) {
    return n * n
}
squareOf(2)     // 4 と評価されます
squareOf('z')   // エラー TS2345: 型 '"z"' の引数を型 'number' のパラメーターに割り当てることはできません
```

このサンプルは，次のことを示しています．

1. ```squareOf``` のパラメータ ```n``` は，```number``` 型に制約されている
2. ```2``` という値の型は，```number``` に割り当てることができる

**型アノテーション** (type annotation: 明示的な型指定) がなければ，```squareOf``` 関数には任意の型の引数を渡すことができます．
しかし，型アノテーションで制約を加えると，関数を呼び出している全ての場所で，互換性のある引数を使って呼び出しているかどうかを検証します．

## 3.2 型の初歩
ここでは，TypeScript がサポートしている型とそれらが保持する値，それを使って何ができるか，そして型エイリアス，合併型，交差型について見ていきます．

### 3.2.1 any
```any``` 型は，コンパイル時にあるものの方がわからない場合に割り当てられる，デフォルトの型です．
```any``` 型ではあらゆることができますが，型チェッカーが働かず，JavaScript と同じような振る舞いになってしまうため，使用は可能な限り避けるべきです．
ただし，稀にですが ```any``` を使わざるを得ない場面があります．

```ts
let a: any = 666        // any
let b: any = ['danger'] // any
let c = a + b           // any
```

この例では，3行目ではエラーを返す必要があるのですが，```any``` 同士の演算結果を格納する変数は ```any``` でなければなりません．
型推論の結果，ある値が ```any``` となる場合には TypeScript がエラーを出すため，明示的で ```any``` であることを示しておく必要があります．

### 3.2.2 unknown
あまり多くはありませんが，本当に型がわからない場合があります．
このときは ```unknown``` 型を用います．
```unknown``` 型には次のような特徴があります．

1. TypeScript が型推論で ```unknown``` と推論することはないため，明示的に型アノテーションする必要がある
2. ```unknown``` 型の値と他の型の値は比較可能
3. ```unknown``` 型が特定の型であることを仮定した処理は実行できない

```ts
let a: unknown = 30 // unknown
let b = a === 123   // boolean
let c = a + 10      // エラー TS2571: オブジェクトの型は 'unknown' です。
if (typeof a === 'number') {
    let d = a + 10  // number
}
```

### 3.2.3 boolean
```boolean``` 型には ```true``` と ```false``` の2つの値があります．
この型は，```==``` や ```===```，```||```，```&&```，```?``` による比較や，```!``` による否定が可能です．

1. TypeScript で値が ```boolean``` であることを推論できる
2. TypeScript で値が特定の ```boolean``` であることを推論できる
3. TypeScript に値が ```boolean``` であることを明示的に示すことができる
4. TypeScript に値が特定の ```boolean``` であることを明示的に示すことができる

```ts
let a = true            // boolean
var b = false           // boolean
const c = true          // true
let d: boolean = true   // boolean
let e: true = true      // true
let f: true = false     // エラー TS2322: 型 'false' を型 'true' に割り当てることはできません
```

一般的なプログラムでは，1や2のように```boolean``` であることを型推論しますが，より型安全性を高めるために4のような方法を用います．
3の方法はほとんど使われません．
2と4の方法では，**リテラル型** を用いて，```boolean``` のうち特定の値に限定しています．
リテラル型とは，ただ1つの値を表し，それ以外の値は受け入れない型のことです．
リテラル型で明示的に型アノテーションすることもできますし，型推論で ```const``` 定数の型を推論するとリテラル型が割り当てられます．

### 3.2.4 number
```number``` 型は整数や浮動小数点数，正数，負数，無限大 (```Infinity```)，非数 (```NaN```) など全ての数値の集まりで，四則演算が行えます．

1. TypeScript で値が ```number``` であることを推論できる
2. ```const``` を使って TypeScript で値が特定の ```number``` であることを推論できる
3. TypeScript に値が ```number``` であることを明示的に示すことができる
4. TypeScript に値が特定の ```number``` であることを明示的に示すことができる

```ts
let a = 1234            // number
var b = Infinity * 0.10 // number
const c = 5678          // 5678
let d = a < b           // boolean
let e: number = 100     // number
let f: 26.218 = 26.218  // 26.218
let g: 26.218 = 10      // エラー TS2322: 型 '10' を型 '26.218' に割り当てることはできません
```

基本的な考え方は ```boolean``` と共通です．

### 3.2.5 bigint
```number``` 型の整数は $2^{53}$ までですが，```bigint``` 型ではそれより大きな整数値を丸め誤差なしに扱うことができるようになります．
値域の違い以外に ```number``` 型と大きな差はありません．

```ts
let a = 1234n           // bigint
const b = 5678n         // 5678n
var c = a + b           // bigint
let d = a < 1235        // boolean
let e = 88.5n           // エラー TS1353: bigint リテラルは整数でなければなりません。
let f: bigint = 100n    // bigint
let g: 100n = 100n      // 100n
let h: bigint = 100     // エラー TS2322: 型 '100' を型 'bigint' に割り当てることはできません。
```

### string
```string``` 型は全ての文字列と，それに対する連結やスライスなどの処理の集まりです．

```ts
let a = 'hello'         // string
var b = 'billy'         // string
const c = '!'           // '!'
let d = a + ' ' + b + c // string
let e: string = 'zoom'  // string
let f: 'john' = 'john'  // 'john'
let g: 'john' = 'zoe'   // エラー TS2322: 型 '"zoe"' を型 '"john"' に割り当てることはできません。
```

型推論の方法などは，```boolean``` や ```number``` と共通です．

### 3.2.7 symbol
```symbol``` 型を用いて，オブジェクトに対するデフォルトのイテレータ (```Symbol.iterator```) を設定したり，オブジェクトが何かのインスタンスであるかどうかを実行時にオーバライド  (```Symbol.hasInstance```) したりできます．
ただし，```symbol``` 型でできることはそれほど多くはありません．

```ts
let a = Symbol('a')         // symbol
let b: symbol = Symbol('b') // symbol
var c = a === b             // boolean
let d = a + 'x'             // エラー TS2469: '+' 演算子を 'symbol' 型に適用することはできません。
```

```symbol``` 型は，```unique symbol``` として明示的に型を示すこともできます．
```unique symbol``` の作成にはいくつかの方法があります．

1. ```const``` 変数に新しい ```Symbol``` を割り当てると，```unique symbol``` で型推論される
   - VSCode などでは ```typeof 変数名``` と表示される
2. ```const``` 変数を明示的に ```unique symbol``` と型アノテートできる
3. ```unique symbol``` は，常にそれ自身と等しくなる
4. ある ```unique symbol``` は，他の ```unique symbol``` とは等しくならない

```ts
const e = Symbol('e')   // typeof e
const f: unique symbol = Symbol('f')    // typeof f
let g: unique symbol = Symbol('f')      // エラー TS1332: 型が 'unique symbol' の変数は，'const' である必要がある
let h = e === e         // boolean
let i = e === f         // エラー TS2367: 型 'unique symbol' と 'unique symbol' は重複しないので，この条件は常に 'false' を返す
```

### 3.2.8 オブジェクト
**構造的型付け (structual typing)** はダックタイピングとも呼ばれ，あるオブジェクトが特定のプロパティを持つことのみを重視して，その名前がなんであるかを考慮しないプログラミングスタイルを指します．
TypeScript は，この構造的型付けのスタイルを取るプログラミング言語です．  
オブジェクトを表現する方法はいくつかありますが，最初に紹介するのは，値を ```object``` として宣言する方法です．

```ts
let a: object = {
    b: 'x'
}
```

しかし，```b``` にアクセスしようとするとエラーになります．

```ts
a.b     // エラー TS2339: プロパティ 'b' は型 'object' に存在しません。
```

これは，```object``` 型が JavaScript のオブジェクトであり，それが ```null``` でないことを表しているだけだからです．  
明示的なアノテーションを削除して，**オブジェクトリテラル表記**で記述すると，オブジェクトの型を推論できます．

```ts
let a = {
    b: 'x'
}       // {b: string}
a.b     // string

let b = {
    c: {
        d: 'f'
    }
}   // {c: {d: string}}
```

また，明示的にオブジェクトの形状を指定することもできます．
この方法では，```let``` の代わりに ```const``` を使って宣言しても，同じ型になります．

```ts
let a: {b: number} = {
    b: 12
}           // {b: number}
```

オブジェクトリテラル表記は，オブジェクトやクラスなどがあることを表現しています．

```ts
let c: {
    firstName: string
    lastName: string
} = {
    firstName: 'john',
    lastName: 'barrowman'
}

class Person {
    constructor(
        public firstName: string,   // public は「this.firstName = firstName」の省略表現です。
        public lastName: string
    ) {}
}
c = new Person('matt', 'smith') // OK
```

```{firstName: string; lastName: string}``` は，オブジェクトの形状 (shape) を表現しており，オブジェクトリテラルとクラスインスタンスの両方がその形状に合致するので，TypeScript は ```Person``` のインスタンスを ```c``` に割り当てることを許可します．
必要なプロパティを省略したり，余分なプロパティを追加したりするとエラーになります．

```ts
let a: {b: number}
a = {} // エラー TS2741: プロパティ 'b' が型 '{}' に欠けていますが、型 '{ b: number; }' で要求されています
a = {
    b: 1,
    c: 2 // エラー TS2322: 型 '{ b: number; c: number; }' を型 '{ b: number; }' に割り当てることはできません。オブジェクト リテラルは既知のプロパティのみ指定できます。'c' は型 '{ b: number; }' に存在しません。
}
```

TypeScript において，オブジェクトのプロパティは厳格にチェックされます．
ただし，省略可能なプロパティを設定したり，任意数のプロパティを持たせたりすることもできます．

1. ```number``` 型のプロパティ ```b``` を持つ
2. ```string``` 型のプロパティ ```c``` を持つ可能性があるが，```undefined``` でも良い
3. ```boolean``` 型のプロパティを任意の数だけ持つことができる．(インデックスシグネチャ：index signature)

```ts
let a: {
    b: number               // 1
    c?: string              // 2
    [key: number]: boolean  // 3
}

a = {b: 1}
a = {b: 1, c: undefined}
a = {b: 1, c: 'd'}
a = {b: 1, 10: true}
a = {b: 1, 10: true, 20: false}
a = {10: true}          // エラー TS2741: プロパティ 'b' が型 '{10: true}' に欠けています。
a = {b: 1, 33: 'red'}   // エラー TS2741: 型 'string' を型 'boolean' に割り当てることはできません。
```

また，```readonly``` 修飾子で初期値で設定した値から変更不可能なプロパティを定義できます．

```ts
let user: {
    readonly firstName: string
} = {
    firstName: 'abby'
}
user.firstName // string
user.firstName = 'abbey with an e'
    // エラー TS2540: 'firstName' は読み取り専用プロパティなので、値を割り当てることはできません
```

オブジェクトリテラル表記のうち，空オブジェクト ```{}``` は ```null``` と ```undefined``` を除いて全ての型に割り当て可能です．
ただし，挙動が分かりづらいので，可能な限り空オブジェクト型は避けるべきです．
また，```Object``` によってオブジェクト型を割り当てることもできますが，こちらも空オブジェクトとほぼ同じ意味になってしまうため，使用は避けるべきでしょう．  
最後に，オブジェクトの宣言方法をまとめます．

1. オブジェクトの持つフィールドがわかっている場合や，全ての値が同じ型を持つ場合にはオブジェクトリテラル表記を用いる
2. 空のオブジェクトリテラル表記を用いる (できるだけ避ける)
3. オブジェクトの持つフィールドを重視しない場合には ```object``` 型を用いる
4. ```Object``` 型 (できるだけ避ける)

TypeScript では1日3の方法でオブジェクトを作成するべきです．

| 値 | {} | object | Object |
| :--: | :--: | :--: | :--: |
| {} | はい | はい | はい| 
| ['a'] | はい | はい | はい| 
| function () {} | はい | はい | はい| 
| new String('a') | はい | はい | はい| 
| 'a' | はい | いいえ | はい| 
| 1 | はい | いいえ | はい| 
| Symbol('a') | はい | いいえ | はい| 
| null | いいえ | いいえ | いいえ |
| undefined | いいえ | いいえ | いいえ |

### 3.2.9 型エイリアス・合併・交差
ここでは，型レベルの演算や操作をいくつか紹介します．

#### 3.2.9.1 型エイリアス
```type``` キーワードを用いて，型に別名を付けることができます．
これを，**型エイリアス** (type alias) と呼びます．

```ts
type Age = number
type Person = {
    name: string
    age: Age
}
```

型エイリアスは型推論されないため，明示的に型付けする必要があります．

```ts
let age: Age = 55
let driver: Person = {
    name: 'James May',
    age: age
}
```

型エイリアスの元の型の値を割り当てることもできます．

```ts
let age = 55
let driver: Person = {
    name: 'James May',
    age: age
}
```

ただし，同じ型を2回以上宣言することはできません．

```ts
type Color = 'red'
type Color = 'blue' // エラー TS2300: 識別子 'Color' が重複しています。
```

一方，型エイリアスはスコープを持つため，内側のスコープ内では外側の型エイリアスを上書きできます．

```ts
type Color = 'red'
let x = Math.random() < .5

if (x) {
    type Color = 'blue' // これは、上で宣言された Color を覆い隠します。
    let b: Color = 'blue'
} else {
    let c: Color = 'red'
}
```

型エイリアスは，繰り返される複雑な型を DRY (Don't Repeat Yourself) に書く場合などに使いますが，それを使うかどうかは値を変数に入れるかどうかと同じ基準で判断します．

#### 3.2.9.2 合併型と交差型
TypeScript には，型の**合併** (union) や**交差** (intersection) を表す特殊な演算子があります．
合併を表現するには ```|``` を，交差を表現するには ```&``` をそれぞれ用います．

```ts
type Cat = {name: string, purrs: boolean}
type Dog = {name: string, barks: boolean, wags: boolean}
type CatOrDogOrBoth = Cat | Dog
type CatAndDog = Cat & Dog
```

上記の例で ```CatOrDogOrBoth``` は，```Cat``` か ```Dog``` あるいはその両方を割り当てることができます．

```ts
// Cat
let a: CatOrDogOrBoth = {
    name: 'Bonkers',
    purrs: true     // のどを鳴らす
}

// Dog
a = {
    name: 'Domino',
    barks: true,    // ほえる
    wags: true      // しっぽを振る
}

// 両方
a = {
    name: 'Donkers',
    barks: true,
    purrs: true,
    wags: true
}
```

```CatAndDog``` は ```Cat``` と ```Dog``` の両方の要素を持ちます．

```ts
let b: CatAndDog = {
    name: 'Domino',
    barks: true,
    purrs: true,
    wags: true
}
```

ここで，次のような関数を考えてみましょう．

```ts
function trueOrNull(isTrue: boolean) {
    if (isTrue) {
        return 'true'
    }
    return null
}
```

この関数の返り値は，```string``` の場合もありますし，```null``` の場合もあります．
そこで，次のようにすることで，```a``` が ```truthy``` であれば戻り値の型は ```string``` になり，そうでなければ ```number``` になります．

```ts
type Returns = string | null

function(a: string, b: number) {
    return a || b
}
```

### 3.2.10 配列
配列は，要素の連結や追加，検索，スライスなどの操作をサポートしています．

```ts
let a = [1, 2, 3]       // number[]
var b = ['a', 'b']      // string[]
let c: string[] = ['a'] // string[]
let d = [1, 'a']        // (string | number)[]
const e = [2, 'b']      // (string | number)[]

let f = ['red']         
f.push('blue')          
f.push(true)    // エラー TS2345: 型 'true' の引数を型 'string' のパラメーターに割り当てることはできません

let g = []      // any[]
g.push(1)       // number[]
g.push('red')   // (string | number)[]

let h: number[] = []    // number[]
h.push(1)               // number[]
h.push('red')           // エラー TS2345: 型 '"red"' の引数を型 'number' のパラメーターに割り当てることはできません
```

上記の例では ```c``` と ```h``` 以外，全てが自動的に型付けされています．
また，```d``` や ```e``` のように，1つの配列に複数の型の値を格納することができますが，実際のプログラムでは全ての要素が同じ型となるように設計すべきです．
```d``` や ```e``` では，```const``` を使うかどうかに関わらず，```(string | number)[]``` 型と推論されます．
```g``` は特殊なケースで，何も型を指定しなければ ```any[]``` 型となり，定義されたスコープから一旦離れたタイミングで最終的な型を割り当てます．

```ts
function buildArray() {
    let a = []  // any[]
    a.push(1)   // number[]
    a.push('x') // (string | number)[]
    return a
}

let myArray = buildArray()  // (string | number)[]
myArray.push(true)          // エラー TS2345: 型 'true' の引数を型 'string | number' のパラメーターに割り当てることはできません
```

### 3.2.11 タプル
**タプル** (tuple) は配列の派生型です．
固定長の配列を片付けするために，タプルの各インデックスの値は特定の既知の型を持ちます．
また，タプルを宣言するときは明示的に型付けする必要があります．

```ts
let a: [number] = [1]   // [ 名前 , 名字 , 生まれ年 ] のタプル
let b: [string, string, number] = ['malcolm', 'gladwell', 1963]
b = ['queen', 'elizabeth', 'ii', 1926]  // エラー TS2322: 型 'string' を型 'number' に割り当てることはできません。
```

```?``` を付けることで省略可能な要素を意味します．

```ts
// 鉄道運賃の配列。方向によって異なる場合があります
let trainFares: [number, number?][] = [
    [3.75],
    [8.25, 7.70],
    [10.50]
]

// これは次のものと同等です
let moreTrainFares: ([number] | [number, number])[] = [
    // ...
]
```

さらに，可変長の要素もサポートしており，最小限の長さを指定できます．

```ts
// 少なくとも 1 つの要素（とそれに続く可変長の要素）を持つ、文字列のリスト
let friends: [string, ...string[]] = ['Sara', 'Tali', 'Chloe', 'Claire']
// 不均一なリスト
let list: [number, boolean, ...string[]] = [1, false, 'a', 'b', 'c']
```

タプルは，不均一なリストを安全にコード化し，その長さを限定できる機能です．

#### 3.2.11.1 読み取り専用の配列とタプル
TypeScript でイミュータブルな配列を定義するには，```readonly``` 配列型を用います．
この場合，配列の要素を直接操作したり，変更を加えるようなメソッドを使ったりすることはできません．
```.concat``` や ```.slice``` のように配列に変更を加えないメソッドを使います．

```ts
let as: readonly number[] = [1, 2, 3]       // readonly number[]
let bs: readonly number[] = as.concat(4)    // readonly number[]
let three = bs[2]                           // number
as[4] = 5   // エラー TS2542: 型 'readonly number[]' のインデックス シグネチャは、読み取りのみを許可します。
as.push(6)  // エラー TS2339: プロパティ 'push' は型 'readonly number[]' に存在しません。
```

読み取り専用の配列やタプルは，次のように宣言することもできます．

```ts
type A = readonly string[]      // readonly string[]
type B = ReadonlyArray<string>  // readonly string[]
type C = Readonly<string[]>     // readonly string[]

type D = readonly [number, string]  // readonly [number, string]
type E = Readonly<[number, string]> // readonly [number, string]
```

ここで，読み取り専用であっても，その実体は JavaScript の配列ですので，それに変更を加えると元の配列をコピーするところから処理が始まります．
すると，パフォーマンスのオーバヘッドが生じるため注意が必要です．

### 3.2.12 null, undefined, void, never
TypeScript ではあるものの欠如を表す型として，```null``` と ```undefined``` をサポートしており，それぞれの値は同名の型を持ちます．
```undefined``` はあるものが未定義であることを意味し，```null``` は欠損していることを意味します．  
これらは，JavaScript でもサポートされていますが，TypeScript では追加で ```void``` と ```never``` もサポートしています．
```void``` は何も返さない関数の戻り値の型を，```never``` は例外をスローするなど処理が戻ることのない関数の型を表します．

```ts
// (a) number または null を返す関数
function a(x: number) {
    if (x < 10) {
        return x
    }
    return null
}

// (b) undefined を返す関数
function b() {
    return undefined
}

// (c) void を返す関数
function c() {
    let a = 2 + 2
    let b = a * a
}

// (d) never を返す関数
function d() {
    throw TypeError('I always error')
}

// (e) never を返すもう 1 つの関数
function e() {
    while (true) {
        doSomething()
    }
}
```

(a) と (b) は明示的に ```null``` や ```undefined``` を返します．
(c) は明示的には何も返していませんが，```undefined``` が返されます．
これを「```void``` を返す」と表現します．
(d) は例外をスローし，(e) は永久に実行されるので，その返り値の型は ```never``` になります．  
```unknown``` は全ての型の**スーパータイプ** (上位型) であり，```never``` は全ての型の**サブタイプ** (派生型) となります．
これを **ボトム型** (bottom type) と呼び，他の全ての型に割り当てることが可能で，コードのどこでも安全に使うことができます．

| 型 | 意味 |
| :--: | :--: |
| null | 値の欠如 |
| undefined | 値がまだ割り当てられていない変数 |
| void | return 文を持たない関数の戻り値 |
| never | 決して戻ることのない関数の戻り値 |

### 3.2.13 列挙型
**列挙型** (enum) は，ある型について取りうる値を列挙する方法です．
列挙型には，文字列から数値へマッピングする数値列挙と，文字列から文字列へマッピングする文字列列挙があります．

```ts
enum Language {
    English,
    Spanish,
    Russian
}
```

自動的に数値を推論してくれますが，明示的に指定することもできます．

```ts
enum Language {
    English = 0,
    Spanish = 1,
    Russian = 2
}
```

値の取得には，ドットか角括弧を用います．

```ts
let myFirstLanguage = Language.Russian      // Language
let mySecondLanguage = Language['English']  // Language
```

値を明示的に指定してやれば，列挙型の宣言を複数に分割することもできます．

```ts
enum Language {
    English = 0,
    Spanish = 1
}

enum Language {
    Russian = 2
}
```

また，計算した値を指定したり，欠損した値を推論したりすることもできます．

```ts
enum Language {
    English = 100,
    Spanish = 200 + 300,
    Russian // TypeScript は 501 と推論します（500 の次の数値）
}
```

さらに，文字列を指定したり，文字列と数値を混ぜたりすることもできます．

```ts
enum Color {
    Red = '#c10000',
    Blue = '#007ac1',
    Pink = 0xc10050,
    White = 255
}

let red = Color.Red
let pink = Color.Pink
```


